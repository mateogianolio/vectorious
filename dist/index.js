var T=Object.defineProperty,Jt=Object.prototype.hasOwnProperty;var P=r=>T(r,"__esModule",{value:!0}),Xt=(r,e)=>{P(r);for(var t in e)T(r,t,{get:e[t],enumerable:!0})},Ht=(r,e)=>{if(P(r),typeof e=="object"||typeof e=="function")for(let t in e)!Jt.call(r,t)&&t!=="default"&&T(r,t,{get:()=>e[t],enumerable:!0});return r},Yt=r=>r&&r.__esModule?r:Ht(T({},"default",{value:r,enumerable:!0}),r);Xt(exports,{NDArray:()=>b,NDIter:()=>p,NDMultiIter:()=>N,V_MAXDIMS:()=>x,abs:()=>O,acos:()=>K,acosh:()=>V,add:()=>rr,angle:()=>tr,array:()=>n,asin:()=>ar,asinh:()=>nr,atan:()=>mr,atanh:()=>pr,augment:()=>M,binOp:()=>fr,cbrt:()=>dr,ceil:()=>br,check:()=>Nr,combine:()=>xr,copy:()=>vr,cos:()=>kr,cosh:()=>Lr,cross:()=>qr,det:()=>Mr,diagonal:()=>Rr,dot:()=>jr,eig:()=>_r,equals:()=>Pr,equidimensional:()=>Br,equilateral:()=>Ur,exp:()=>$r,expm1:()=>Jr,eye:()=>w,fill:()=>Hr,floor:()=>Wr,forEach:()=>Qr,fround:()=>ee,gauss:()=>ie,get:()=>se,inv:()=>ce,log:()=>ue,log10:()=>fe,log1p:()=>de,log2:()=>be,lu:()=>Ne,lu_factor:()=>xe,magic:()=>Ut,map:()=>ve,matrix:()=>R,max:()=>ke,mean:()=>Le,min:()=>qe,multiply:()=>Me,norm:()=>Re,normalize:()=>je,ones:()=>Kt,pow:()=>_e,prod:()=>Pe,product:()=>Be,project:()=>Ue,push:()=>$e,random:()=>$t,range:()=>Vt,rank:()=>Je,reciprocal:()=>He,reduce:()=>We,reshape:()=>Qe,round:()=>et,row_add:()=>ot,scale:()=>it,set:()=>st,sign:()=>ct,sin:()=>ut,sinh:()=>ft,slice:()=>dt,solve:()=>bt,sqrt:()=>Nt,square:()=>xt,subtract:()=>vt,sum:()=>kt,swap:()=>Lt,tan:()=>qt,tanh:()=>Mt,toArray:()=>Rt,toString:()=>Ct,trace:()=>_t,transpose:()=>Pt,trunc:()=>Bt,zeros:()=>A});const S=r=>r.reduce((e,t)=>e.concat(Array.isArray(t)?S(t):t),[]),j=r=>ArrayBuffer.isView(r)&&!(r instanceof DataView),F=r=>r.reduce((e,t)=>e*t,1),C=r=>Array.isArray(r)||j(r)?[r.length].concat(C(r[0])):[],v=r=>[...r.slice(1).map((e,t)=>r.slice(t+1).reduce((o,i)=>o*i,1)),1],B=r=>{const{constructor:{name:e="Float32Array"}={}}=r||{};switch(e){case"Int8Array":return"int8";case"Uint8Array":return"uint8";case"Int16Array":return"int16";case"Uint16Array":return"uint16";case"Int32Array":return"int32";case"Uint32Array":return"uint32";case"Uint8ClampedArray":return"uint8c";case"Float32Array":return"float32";case"Float64Array":return"float64";default:return"float64"}},D=r=>{switch(r){case"int8":return Int8Array;case"uint8":return Uint8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"uint8c":return Uint8ClampedArray;case"float32":return Float32Array;case"float64":return Float64Array;default:return Float64Array}};const n=(...r)=>new b(...r);const x=32;class p{constructor(r){const{shape:e,strides:t,length:o}=n(r);this.x=n(r),this.length=o,this.lengthm1=o-1,this.nd=e.length,this.ndm1=this.nd-1,this.shape=Array(x).fill(0),this.strides=Array(x).fill(0),this.shapem1=Array(x).fill(0),this.coords=Array(x).fill(0),this.backstrides=Array(x).fill(0),this.factors=Array(x).fill(0),this.nd!==0&&(this.factors[this.nd-1]=1),this.contiguous=!0;let i=1,a;for(a=0;a<this.nd;a+=1)this.shape[a]=e[a],this.shapem1[a]=e[a]-1,this.strides[a]=t[a],this.backstrides[a]=t[a]*this.shapem1[a],this.coords[a]=0,e[this.nd-a-1]!==1&&(t[a]!==i&&(this.contiguous=!1),i*=e[this.nd-a-1]),a>0&&(this.factors[this.nd-a-1]=this.factors[this.nd-a]*e[this.nd-a]);this.index=0,this.pos=0}done(){return this.index>this.lengthm1}current(){const r=this.done();return{value:r?void 0:this.pos,done:r}}next1d(){const{strides:r,coords:e}=this;this.pos+=r[0],e[0]+=1}nextcontiguous(){this.pos+=1}next2d(){const{coords:r,strides:e,shapem1:t,backstrides:o}=this;r[1]<t[1]?(r[1]+=1,this.pos+=e[1]):(r[1]=0,r[0]+=1,this.pos+=e[0]-o[1])}nextnd(){const{ndm1:r,shapem1:e,coords:t,strides:o,backstrides:i}=this;let a;for(a=r;a>=0;a-=1)if(t[a]<e[a]){t[a]+=1,this.pos+=o[a];break}else t[a]=0,this.pos-=i[a]}next(){const r=this.current();this.index+=1;const{ndm1:e,contiguous:t}=this;return e===0?this.next1d():t?this.nextcontiguous():e===1?this.next2d():this.nextnd(),r}[Symbol.iterator](){return this}}class N{constructor(...r){this.iters=r.map(c=>new p(c)),this.numiter=r.length;let e,t;for(e=0,t=0;e<this.numiter;e+=1)t=Math.max(t,this.iters[e].x.shape.length);this.nd=t,this.shape=Array(t).fill(0);let o,i,a,s;for(e=0;e<t;e+=1)for(this.shape[e]=1,i=0;i<this.numiter;i+=1)if(o=this.iters[i],a=e+o.x.shape.length-t,a>=0){if(s=o.x.shape[a],s==1)continue;if(this.shape[e]==1)this.shape[e]=s;else if(this.shape[e]!==s)throw new Error("shape mismatch")}for(s=this.shape.reduce((c,m)=>c*m,1),this.length=s,this.lengthm1=s-1,e=0;e<this.numiter;e+=1)for(o=this.iters[e],o.nd=this.nd,o.ndm1=this.nd-1,o.length=s,o.lengthm1=s-1,t=o.x.shape.length,t!==0&&(o.factors[this.nd-1]=1),i=0;i<this.nd;i+=1)o.shape[i]=this.shape[i],o.shapem1[i]=this.shape[i]-1,a=i+t-this.nd,a<0||o.x.shape[a]!==this.shape[i]?(o.contiguous=!1,o.strides[i]=0):o.strides[i]=o.x.strides[a],o.backstrides[i]=o.strides[i]*o.shapem1[i],i>0&&(o.factors[this.nd-i-1]=o.factors[this.nd-i]*this.shape[this.nd-i]);this.index=0,this.pos=Array(this.numiter).fill(0)}done(){return this.index>this.lengthm1}current(){const r=this.done();return{value:r?void 0:this.pos,done:r}}next(){const r=this.current();this.index+=1;const{numiter:e}=this;let t,o;for(o=0;o<e;o+=1)t=this.iters[o],this.pos[o]=t.pos,t.next();return r}[Symbol.iterator](){return this}}const{abs:Wt}=Math,O=r=>n(r).abs();function U(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=Wt(r[t]);return this}const{acos:Zt}=Math,K=r=>n(r).acos();function $(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=Zt(r[t]);return this}const{acosh:Qt}=Math,V=r=>n(r).acosh();function J(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=Qt(r[t]);return this}let h;try{h=require("nblas")}catch(r){}const _=h&&h.NoTrans,$o=h&&h.Trans;function X(r,e,t,o,i,a,s){if(o.length/i!==e||a.length/s!==e)throw new Error("lengths do not match");switch(r){case"float64":return h.daxpy(e,t,o,i,a,s);case"float32":return h.saxpy(e,t,o,i,a,s);default:throw new Error("wrong dtype")}}function H(r,e,t,o,i,a){if(t.length/o!==e||i.length/a!==e)throw new Error("lengths do not match");switch(r){case"float64":return h.ddot(e,t,o,i,a);case"float32":return h.sdot(e,t,o,i,a);default:throw new Error("wrong dtype")}}function Y(r,e,t,o){if(t.length/o!==e)throw new Error("lengths do not match");switch(r){case"float64":return h.idamax(e,t,o);case"float32":return h.isamax(e,t,o);default:throw new Error("wrong dtype")}}function W(r,e,t,o,i,a,s,c,m,u,y,f,l,d){const{length:I}=c,{length:G}=u,{length:q}=l;if(e===h.NoTrans&&I!==m*o||e===h.Trans&&I!==m*a)throw new Error("lengths do not match");if(t===h.NoTrans&&G!==y*a||t===h.Trans&&G!==y*i)throw new Error("lengths do not match");if(q!==d*o)throw new Error("lengths do not match");switch(r){case"float64":return h.dgemm(e,t,o,i,a,s,c,m,u,y,f,l,d);case"float32":return h.sgemm(e,t,o,i,a,s,c,m,u,y,f,l,d);default:throw new Error("wrong dtype")}}function Z(r,e,t,o){if(t.length/o!==e)throw new Error("lengths do not match");switch(r){case"float64":return h.dnrm2(e,t,o);case"float32":return h.snrm2(e,t,o);default:throw new Error("wrong dtype")}}function Q(r,e,t,o,i){if(o.length/i!==e)throw new Error("lengths do not match");switch(r){case"float64":return h.dscal(e,t,o,i);case"float32":return h.sscal(e,t,o,i);default:throw new Error("wrong dtype")}}const rr=(r,e,t=1)=>n(r).add(n(e),t);function er(r,e=1){const{data:t,length:o,dtype:i}=this,{data:a}=n(r);try{X(i,o,e,a,1,t,1)}catch(s){const c=new N(this,r);for(const[m,u]of c)t[m]+=e*a[u]}return this}const{acos:ro}=Math,tr=(r,e)=>n(r).angle(n(e));function or(r){return ro(this.dot(n(r))/this.norm()/n(r).norm())}const{asin:eo}=Math,ar=r=>n(r).asin();function ir(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=eo(r[t]);return this}const{asinh:to}=Math,nr=r=>n(r).asinh();function sr(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=to(r[t]);return this}const{atan:oo}=Math,mr=r=>n(r).atan();function cr(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=oo(r[t]);return this}const{atanh:ao}=Math,pr=r=>n(r).atanh();function ur(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=ao(r[t]);return this}const A=(...r)=>new b(new Float64Array(r.reduce((e,t)=>e*t,1)),{shape:r}).fill(0);const M=(r,e)=>n(r).augment(n(e));function yr(r){const[e,t]=this.shape,[o,i]=n(r).shape,{data:a}=this,{data:s}=n(r);if(o===0||i===0)return this;if(e!==o)throw new Error("rows do not match");const c=A(e,t+i),{data:m}=c;let u,y;for(u=0;u<e;u+=1)for(y=0;y<t;y+=1)m[u*(t+i)+y]=a[u*t+y];for(u=0;u<o;u+=1)for(y=0;y<i;y+=1)m[u*(t+i)+(y+t)]=s[u*i+y];return c}const fr=(r,e,t)=>n(r).binOp(n(e),t);function lr(r,e){const{data:t}=this,{data:o}=n(r),i=new N(this,r);for(const[a,s]of i)t[a]=e(t[a],o[s],a);return this}const{cbrt:io}=Math,dr=r=>n(r).cbrt();function hr(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=io(r[t]);return this}const{ceil:no}=Math,br=r=>n(r).ceil();function Ar(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=no(r[t]);return this}const Nr=(r,...e)=>{n(r).check(...e)};function Dr(...r){const{shape:e,length:t}=this;if(r.length===1){const[o]=r;if(o<0||o>t-1||!Number.isFinite(o))throw new Error("index out of bounds")}else if(!e.every((o,i)=>o>r[i]&&Number.isFinite(r[i])&&r[i]>=0))throw new Error("index out of bounds")}const xr=(r,e)=>n(r).combine(n(e));function gr(r){if(this.shape.length!==1&&r.shape.length!==1)throw new Error("combine operation not permitted for multidimensional arrays");const{length:e,data:t}=this,{length:o,data:i}=r;if(o===0)return this;if(e===0)return this.data=new(D(r.dtype))(i),this.length=o,this.dtype=r.dtype,this;const a=e+o,s=new(D(this.dtype))(a);return s.set(t),s.set(i,e),this.data=s,this.length=a,this.shape=[a],this}const vr=r=>n(r).copy();function wr(){const r=Object.assign(Object.create(Object.getPrototypeOf(this)),this);return r.data=this.data.slice(),r.shape=this.shape.slice(),r.strides=this.strides.slice(),r.length=this.length,r.dtype=this.dtype,r}const{cos:so}=Math,kr=r=>n(r).cos();function Ir(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=so(r[t]);return this}const{cosh:mo}=Math,Lr=r=>n(r).cosh();function Gr(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=mo(r[t]);return this}const qr=(r,e)=>n(r).cross(n(e));function Tr(r){const{length:e}=this,{length:t}=r;if(e!==3||t!==3)throw new Error("vectors must have three components");const o=this.y*r.z-this.z*r.y,i=this.z*r.x-this.x*r.z,a=this.x*r.y-this.y*r.x;return this.x=o,this.y=i,this.z=a,this}const Mr=r=>n(r).det();function Er(){this.square();const[r]=this.shape,[e,t]=this.copy().lu_factor(),{data:o}=e;let i=1,a=1,s;for(s=0;s<r;s+=1)i*=o[s*r+s],s!==t[s]-1&&(a*=-1);return a*i}const Rr=r=>n(r).diagonal();function Sr(){this.square();const{length:r}=this,[e,t]=this.shape,o=Math.min(e,t);return this.reshape(r).slice(0,r,o+1)}const jr=(r,e)=>n(r).dot(n(e));function Cr(r){const{data:e,length:t,dtype:o}=this,{data:i}=r;let a=0;try{a=H(o,t,i,1,e,1)}catch(s){const c=new N(this,r);for(const[m,u]of c)a+=e[m]*i[u]}return a}const w=r=>{const e=new b(new Float64Array(r*r),{shape:[r,r]}),{data:t}=e;let o;for(o=0;o<r;o+=1)t[o*r+o]=1;return e};let L;try{L=require("nlapack")}catch(r){}const E=(r,e,t,o,i,a,s)=>{const[c]=r.shape,{data:m}=r,u=m[o*c+i],y=1/(e+t);m[o*c+i]=u-t*(m[a*c+s]+y*u),m[a*c+s]+=t*(u-y*m[a*c+s])},_r=r=>n(r).eig();function zr(){this.square();const[r]=this.shape;try{["float32","float64"].includes(this.dtype)||(this.dtype="float32",this.data=D(this.dtype).from(this.data));const e=L.NoEigenvector,t=L.Eigenvector,o=A(r),i=A(r),a=A(r,r),s=A(r,r),{data:c}=this,{data:m}=o,{data:u}=i,{data:y}=a,{data:f}=s;return this.dtype==="float64"&&L.dgeev(e,t,r,c,r,m,u,y,r,f,r),this.dtype==="float32"&&L.sgeev(e,t,r,c,r,m,u,y,r,f,r),[o,s]}catch(e){const{data:t}=this,o=w(r);let i=0,a=0,s=0,c=0,m=0;do{for(a=0;a<r;a+=1)for(s=a+1;s<r;s+=1)Math.abs(t[a*r+s])>=i&&(i=Math.abs(t[a*r+s]),c=a,m=s);let u;if(Math.abs(t[c*r+m])<Math.abs(t[m*r+m])*1e-36)u=t[c*r+m]/t[m*r+m];else{const d=t[m*r+m]/2*t[c*r+m];u=1/(Math.abs(d)+Math.sqrt(d*d+1))}const y=1/Math.sqrt(u*u+1),f=u*y,l=t[c*r+m];for(t[c*r+m]=0,t[c*r+c]-=u*l,t[m*r+m]+=u*l,a=0;a<c;a+=1)E(this,y,f,a,c,a,m);for(a=c+1;a<m;a+=1)E(this,y,f,c,a,a,m);for(a=m+1;a<r;a+=1)E(this,y,f,c,a,m,a);for(a=0;a<r;a+=1)E(o,y,f,a,c,a,m)}while(i>=1e-9);return[this.diagonal(),o]}}const Pr=(r,e,t=1e-6)=>n(r).equals(n(e),t);function Fr(r,e=1e-6){const{data:t}=this,{data:o}=r,i=new N(this,r);for(const[a,s]of i)if(Math.abs(t[a]-o[s])>e)return!1;return!0}const Br=(r,e)=>{n(r).equidimensional(n(e))};function Or(r){const{shape:e}=this,{shape:t}=r;if(!e.every((o,i)=>o===t[i]))throw new Error(`shapes ${e} and ${t} do not match`)}const Ur=(r,e)=>{n(r).equilateral(n(e))};function Kr(r){const{length:e}=this,{length:t}=r;if(e!==t)throw new Error(`lengths ${e} and ${t} do not match`)}const{exp:co}=Math,$r=r=>n(r).exp();function Vr(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=co(r[t]);return this}const{expm1:po}=Math,Jr=r=>n(r).expm1();function Xr(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=po(r[t]);return this}const Hr=(r,e=0)=>n(r).fill(e);function Yr(r=0){const{data:e}=this,t=new p(this);for(const o of t)e[o]=r instanceof Function?r(t.pos):r;return this}const{floor:uo}=Math,Wr=r=>n(r).floor();function Zr(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=uo(r[t]);return this}const Qr=(r,e)=>{r.forEach(e)};function re(r){const{data:e}=this,t=new p(this);for(const o of t)r.call(this,e[o],o,e)}const{fround:yo}=Math,ee=r=>n(r).fround();function te(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=yo(r[t]);return this}let g;try{g=require("nlapack")}catch(r){}function k(r,e,t,o,i,a){if(o.length!==e*t)throw new Error("lengths do not match");switch(r){case"float64":return g.dgetrf(e,t,o,i,a);case"float32":return g.sgetrf(e,t,o,i,a);default:throw new Error("wrong dtype")}}function oe(r,e,t,o,i){if(t.length!==e*e)throw new Error("lengths do not match");switch(r){case"float64":return g.dgetri(e,t,o,i);case"float32":return g.sgetri(e,t,o,i);default:throw new Error("wrong dtype")}}function ae(r,e,t,o,i,a,s,c){if(o.length!==i*e||s.length!==c*t)throw new Error("lengths do not match");switch(r){case"float64":return g.dgesv(e,t,o,i,a,s,c);case"float32":return g.sgesv(e,t,o,i,a,s,c);default:throw new Error("wrong dtype")}}const ie=r=>n(r).gauss();function ne(){const{shape:[r,e],data:t,dtype:o}=this;try{const{data:i}=this,a=new Int32Array(Math.min(r,e));k(o,r,e,i,e,a);const s=new p(this);let[c,m]=s.coords;for(const u of s)m<c&&(i[u]=0),[c,m]=s.coords}catch(i){let a=0,s,c,m,u,y;for(m=0;m<r;m+=1){if(e<=a)return this;for(u=m;t[u*e+a]===0;)if(u+=1,r===u&&(u=m,a+=1,e===a))return this;if(m!==u&&this.swap(m,u),c=t[m*e+a],c!==0)for(y=0;y<e;y+=1)t[m*e+y]/=c;for(u=0;u<r;u+=1)if(s=t[u*e+a],u!==m)for(y=0;y<e;y+=1)t[u*e+y]-=t[m*e+y]*s;a+=1}for(m=0;m<r;m+=1){for(c=0,u=0;u<e;u+=1)c===0&&(c=t[m*e+u]);if(c===0)for(y=0;y<e;y+=1)t[m*e+y]/=c}}return this}const se=(r,...e)=>n(r).get(...e);function me(...r){this.check(...r);const{data:e,shape:t}=this,{length:o}=t;let i=r[o-1],a,s;for(a=0;a<o-1;a+=1){let c=1;for(s=a+1;s<o;s+=1)c*=t[s];i+=r[a]*c}return e[i]}const ce=r=>n(r).inv();function pe(){this.square();const{shape:[r],dtype:e}=this;try{const{data:t}=this,o=new Int32Array(r);return k(e,r,r,t,r,o),oe(e,r,t,r,o),this}catch(t){const o=w(r),i=M(this,o).gauss(),a=A(r,r),s=A(r,r),{data:c}=i,{data:m}=a,{data:u}=s,y=new p(i);let[f,l]=y.coords;for(const d of y)l<r?m[f*r+l]=c[d]:u[f*r+(l-r)]=c[d],[f,l]=y.coords;if(!a.equals(o))throw new Error("matrix is not invertible");return s}}const{log:fo}=Math,ue=r=>n(r).log();function ye(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=fo(r[t]);return this}const{log10:lo}=Math,fe=r=>n(r).log10();function le(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=lo(r[t]);return this}const{log1p:ho}=Math,de=r=>n(r).log1p();function he(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=ho(r[t]);return this}const{log2:bo}=Math,be=r=>n(r).log2();function Ae(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=bo(r[t]);return this}const Ne=r=>n(r).lu();function De(){const[r,e]=this.copy().lu_factor(),t=r.copy(),o=r.copy(),{data:i}=t,{data:a}=o,s=new p(r);let[c,m]=s.coords;for(const u of s)m<c?a[u]=0:i[u]=c===m?1:0,[c,m]=s.coords;return[t,o,e]}const xe=r=>n(r).lu_factor();function ge(){const{data:r,shape:[e],dtype:t}=this,o=new Int32Array(e);try{k(t,e,e,r,e,o)}catch(i){let a,s,c,m,u,y,f;for(f=0;f<e;f+=1){for(m=f,a=Math.abs(r[f*e+f]),y=f+1;y<e;y+=1)s=Math.abs(r[y*e+f]),a<s&&(a=s,m=y);for(o[f]=m+1,m!==f&&this.swap(f,m),c=r[f*e+f],u=f+1;u<e;u+=1)r[u*e+f]/=c;for(u=f+1;u<e;u+=1){for(y=f+1;y<e-1;y+=2)r[u*e+y]-=r[u*e+f]*r[f*e+y],r[u*e+y+1]-=r[u*e+f]*r[f*e+y+1];y===e-1&&(r[u*e+y]-=r[u*e+f]*r[f*e+y])}}}return[this,o]}const ve=(r,e)=>n(r).map(e);function we(r){const{data:e}=this,t=new p(this),o=r.bind(this),i=this.copy(),{data:a}=i;for(const s of t)a[s]=o(e[s],s,e);return i}const ke=r=>n(r).max();function Ie(){const{data:r,length:e,dtype:t}=this;let o=Number.NEGATIVE_INFINITY;try{o=r[Y(t,e,r,1)]}catch(i){const a=new p(this);for(const s of a){const c=r[s];o<c&&(o=c)}}return o}const Le=r=>n(r).mean();function Ge(){const{data:r,length:e}=this,t=new p(this);let o=0;for(const i of t)o+=r[i];return o/e}const qe=r=>n(r).min();function Te(){const{data:r}=this,e=new p(this);let t=Number.POSITIVE_INFINITY;for(const o of e){const i=r[o];t>i&&(t=i)}return t}const R=(r,e)=>new b(new Float64Array(r*e),{shape:[r,e]});const Me=(r,e)=>n(r).multiply(n(e));function Ee(r){const{shape:[e,t],data:o,dtype:i}=this,{shape:[a,s],data:c}=r;if(t!==a)throw new Error("sizes do not match");const m=R(e,s),{data:u}=m;try{W(i,_,_,e,s,t,1,o,t,c,s,0,u,s)}catch(y){const f=new p(m);let l,[d,I]=f.coords;for(const G of f){let q=0;for(l=0;l<t;l+=1)q+=o[d*t+l]*c[l*s+I];u[G]=q,[d,I]=f.coords}}return m}const{sqrt:Ao}=Math,Re=r=>n(r).norm();function Se(){const{data:r,length:e,dtype:t}=this;let o=0;try{o=Z(t,e,r,1)}catch(i){o=Ao(this.dot(this))}return o}const je=r=>n(r).normalize();function Ce(){return this.scale(1/this.norm())}const{pow:No}=Math,_e=(r,e)=>n(r).pow(e);function ze(r){const{data:e}=this,t=new p(this);for(const o of t)e[o]=No(e[o],r);return this}const Pe=r=>n(r).prod();function Fe(){const{data:r}=this,e=new p(this);let t=1;for(const o of e)t*=r[o];return t}const Be=(r,e)=>n(r).product(n(e));function Oe(r){const{data:e}=this,{data:t}=r,o=new N(this,r);for(const[i,a]of o)e[i]*=t[a];return this}const Ue=(r,e)=>n(r).project(n(e));function Ke(r){return r.scale(this.dot(r)/r.dot(r))}const $e=(r,e)=>n(r).push(e);function Ve(r){if(this.shape.length!==1)throw new Error("push operation not permitted for multidimensional arrays");const{data:e,length:t}=this,o=t+1,i=new(D(this.dtype))(o);return i.set(e),i[t]=r,this.data=i,this.length=o,this.shape=[o],this}const Je=(r,e=1e-6)=>n(r).rank(e);function Xe(r=1e-6){const{data:e}=this.copy().gauss(),t=new p(this);let o=0,[i,a]=t.coords;for(const s of t)o<=i&&a>=i&&e[s]>r&&(o+=1),[i,a]=t.coords;return o}const He=r=>n(r).reciprocal();function Ye(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=1/r[t];return this}const We=(r,e,t)=>n(r).reduce(e,t);function Ze(r,e){const{data:t,length:o}=this;if(o===0&&typeof e=="undefined")throw new Error("Reduce of empty array with no initial value.");const i=new p(this),a=r.bind(this);let s;typeof e=="undefined"?(s=t[0],i.next()):s=e;for(const c of i)s=a(s,t[c],c,t);return s}const Qe=(r,...e)=>n(r).reshape(...e);function rt(...r){const{length:e}=this;if(r.reduce((t,o)=>t*o,1)!==e)throw new Error(`shape ${r} does not match length ${e}`);return this.shape=r,this.strides=v(r),this}const{round:Do}=Math,et=r=>n(r).round();function tt(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=Do(r[t]);return this}const ot=(r,e,t,o=1)=>n(r).row_add(e,t,o);function at(r,e,t=1){this.check(r,0),this.check(e,0);const[,o]=this.shape,{data:i}=this;let a;for(a=0;a<o;a+=1)i[r*o+a]+=i[e*o+a]*t;return this}const it=(r,e)=>n(r).scale(e);function nt(r){const{data:e,length:t,dtype:o}=this;try{Q(o,t,r,e,1)}catch(i){const a=new p(this);for(const s of a)e[s]*=r}return this}const st=(r,...e)=>{r.set(...e)};function mt(...r){const e=r.slice(0,-1),t=r[r.length-1];this.check(...e);const{shape:o}=this;let i=e[e.length-1],a;for(a=0;a<e.length-1;a+=1)i+=e[a]*o[a+1];this.data[i]=t}const{sign:xo}=Math,ct=r=>n(r).sign();function pt(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=xo(r[t]);return this}const{sin:go}=Math,ut=r=>n(r).sin();function yt(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=go(r[t]);return this}const{sinh:vo}=Math,ft=r=>n(r).sinh();function lt(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=vo(r[t]);return this}const dt=(r,e,t,o)=>n(r).slice(e,t,o);function ht(r=0,e=this.shape[0],t=1){const{shape:o}=this,i=o.length;if(r<0||e<0)return this.slice(r<0?i+r:r,e<0?i+e:e);if(t===0)throw new Error("step argument cannot be 0");const a=[Math.ceil((e-r)/t),...o.slice(1)],s=a.reduce((m,u)=>m*u,1),c=v(a);return this.shape=a,this.length=s,this.strides=c,this}const bt=(r,e)=>n(r).solve(n(e));function At(r){const{data:e,dtype:t}=this,{data:o,shape:[i,a]}=r;try{const s=new Int32Array(i);ae(t,i,a,e,i,s,o,a)}catch(s){const[c,m]=this.lu_factor(),{data:u}=c,{data:y}=r;let f,l,d;for(f=0;f<m.length;f+=1)f!==m[f]-1&&r.swap(f,m[f]-1);for(d=0;d<a;d+=1){for(f=0;f<i;f+=1)for(l=0;l<f;l+=1)y[f*a+d]-=u[f*i+l]*y[l*a+d];for(f=i-1;f>=0;f-=1){for(l=f+1;l<i;l+=1)y[f*a+d]-=u[f*i+l]*y[l*a+d];y[f*a+d]/=u[f*i+f]}}}return r}const{sqrt:wo}=Math,Nt=r=>n(r).sqrt();function Dt(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=wo(r[t]);return this}const xt=r=>{n(r).square()};function gt(){const{length:r}=this.shape,[e,t]=this.shape;if(r!==2||e!==t)throw new Error("matrix is not square")}const vt=(r,e)=>n(r).subtract(n(e));function wt(r){return this.add(r,-1)}const kt=r=>n(r).sum();function It(){const{data:r}=this,e=new p(this);let t=0;for(const o of e)t+=r[o];return t}const Lt=(r,e,t)=>n(r).swap(e,t);function Gt(r,e){this.check(r,0),this.check(e,0);const{data:t}=this,[,o]=this.shape,i=t.slice(r*o,(r+1)*o);return t.copyWithin(r*o,e*o,(e+1)*o),t.set(i,e*o),this}const{tan:ko}=Math,qt=r=>n(r).tan();function Tt(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=ko(r[t]);return this}const{tanh:Io}=Math,Mt=r=>n(r).tanh();function Et(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=Io(r[t]);return this}const Rt=r=>n(r).toArray();function St(){const{length:r,shape:e}=this,{length:t}=e;let o,i,a;const s=[];for(o=0;o<r;o+=1){const c=[];for(i=0;i<t;i+=1){let u=1;for(a=i+1;a<t;a+=1)u*=e[a];let y=Math.floor(o/u);i>0&&(y%=e[i]),c.push(y)}let m=s;for(i=0;i<t;i+=1){const u=c[i];i<t-1?(m[u]||(m[u]=[]),m=m[u]):m[u]=this.get(...c)}}return s}const jt=Yt(require("util"));const Ct=r=>n(r).toString();function z(){return`array(${jt.inspect(this.toArray(),{depth:10,breakLength:40})}, dtype=${this.dtype})`}const _t=r=>n(r).trace();function zt(){const[r,e]=this.shape,{data:t}=this,o=Math.min(r,e);let i=0,a;for(a=0;a<o;a+=1)i+=t[a*e+a];return i}const Pt=r=>n(r).transpose();function Ft(){if(this.shape.length<2)return this;let r=this.shape[0];return this.shape[0]=this.shape[1],this.shape[1]=r,r=this.strides[0],this.strides[0]=this.strides[1],this.strides[1]=r,this}const{trunc:Lo}=Math,Bt=r=>n(r).trunc();function Ot(){const{data:r}=this,e=new p(this);for(const t of e)r[t]=Lo(r[t]);return this}const Ut=r=>{if(r<0)throw new Error("invalid n");const e=new Float64Array(r*r),t=new b(e,{shape:[r,r]}),o=new p(t);let[i,a]=o.coords;for(const s of o){const c=r-i-1,m=r-a-1;e[s]=(a+c*2+1)%r*r+(m+c*2+1)%r+1,[i,a]=o.coords}return t};const Kt=(...r)=>new b(new Float64Array(r.reduce((e,t)=>e*t,1)),{shape:r}).fill(1);const $t=(...r)=>new b(new Float64Array(r.reduce((e,t)=>e*t,1)),{shape:r}).map(()=>Math.random());const Vt=(...r)=>{const e=Float32Array;let t=!1,o,i,a;switch(r.length){case 2:a=r.pop(),i=1,o=r.pop();break;case 3:a=r.pop(),i=r.pop(),o=r.pop();break;default:throw new Error("invalid range")}if(a-o<0){const u=a;a=o,o=u,t=!0}if(i>a-o)throw new Error("invalid range");const s=new e(Math.ceil((a-o)/i));let c=o,m=0;if(t)for(;c<a;c+=i,m+=1)s[m]=a-c+o;else for(;c<a;c+=i,m+=1)s[m]=c;return new b(s)};const Go=Symbol.for("nodejs.util.inspect.custom");var lu;class b{constructor(r,e){this.data=new Float64Array(0);this.dtype="float64";this.length=0;this.shape=[0];this.strides=[0];this[lu]=z;this.abs=U;this.acos=$;this.acosh=J;this.add=er;this.angle=or;this.asin=ir;this.asinh=sr;this.atan=cr;this.atanh=ur;this.augment=yr;this.binOp=lr;this.cbrt=hr;this.ceil=Ar;this.check=Dr;this.combine=gr;this.copy=wr;this.cos=Ir;this.cosh=Gr;this.cross=Tr;this.det=Er;this.diagonal=Sr;this.dot=Cr;this.eig=zr;this.equals=Fr;this.equidimensional=Or;this.equilateral=Kr;this.exp=Vr;this.expm1=Xr;this.fill=Yr;this.floor=Zr;this.forEach=re;this.fround=te;this.gauss=ne;this.get=me;this.inv=pe;this.log=ye;this.log10=le;this.log1p=he;this.log2=Ae;this.lu=De;this.lu_factor=ge;this.map=we;this.max=Ie;this.mean=Ge;this.min=Te;this.multiply=Ee;this.norm=Se;this.normalize=Ce;this.pow=ze;this.prod=Fe;this.product=Oe;this.project=Ke;this.push=Ve;this.rank=Xe;this.reciprocal=Ye;this.reduce=Ze;this.reshape=rt;this.round=tt;this.row_add=at;this.scale=nt;this.set=mt;this.sign=pt;this.sin=yt;this.sinh=lt;this.slice=ht;this.solve=At;this.sqrt=Dt;this.square=gt;this.subtract=wt;this.sum=It;this.swap=Gt;this.tan=Tt;this.tanh=Et;this.toArray=St;this.toString=z;this.trace=zt;this.transpose=Ft;this.trunc=Ot;if(!r)return;if(r instanceof b)return r.copy();if(r instanceof p){if(!e||!e.dtype)throw new Error("dtype is missing");r.shape&&(e.shape=r.shape);const s=r.length;r=new(D(e.dtype))(s)}const{shape:t=C(r),length:o=F(t),strides:i=v(t),dtype:a=B(r)}=e||{};this.data=j(r)?r:new(D(a))(S(r)),this.shape=t,this.length=o,this.dtype=a,this.strides=i}get x(){return this.get(0)}set x(r){this.set(0,r)}get y(){return this.get(1)}set y(r){this.set(1,r)}get z(){return this.get(2)}set z(r){this.set(2,r)}get w(){return this.get(3)}set w(r){this.set(3,r)}get T(){return this.copy().transpose()}}lu=Go;try{window.v=b}catch(r){}
//# sourceMappingURL=index.js.map
