var T=Object.defineProperty,Je=Object.prototype.hasOwnProperty;var F=r=>T(r,"__esModule",{value:!0}),Xe=(r,t)=>{F(r);for(var e in t)T(r,e,{get:t[e],enumerable:!0})},He=(r,t)=>{if(F(r),typeof t=="object"||typeof t=="function")for(let e in t)!Je.call(r,e)&&e!=="default"&&T(r,e,{get:()=>t[e],enumerable:!0});return r},Ye=r=>r&&r.__esModule?r:He(T({},"default",{value:r,enumerable:!0}),r);Xe(exports,{NDArray:()=>h,NDIter:()=>p,NDMultiIter:()=>N,V_MAXDIMS:()=>x,abs:()=>O,acos:()=>K,acosh:()=>V,add:()=>rr,angle:()=>er,array:()=>n,asin:()=>ar,asinh:()=>nr,atan:()=>mr,atanh:()=>pr,augment:()=>E,binOp:()=>fr,cbrt:()=>dr,ceil:()=>Ar,check:()=>Nr,combine:()=>xr,copy:()=>vr,cos:()=>kr,cosh:()=>Lr,cross:()=>qr,det:()=>Mr,diagonal:()=>Rr,dot:()=>jr,eig:()=>zr,equals:()=>Pr,equidimensional:()=>Br,equilateral:()=>Ur,exp:()=>$r,expm1:()=>Jr,eye:()=>w,fill:()=>Hr,floor:()=>Wr,forEach:()=>Qr,fround:()=>tt,gauss:()=>it,get:()=>st,inv:()=>ct,log:()=>ut,log10:()=>ft,log1p:()=>dt,log2:()=>At,lu:()=>Nt,lu_factor:()=>xt,magic:()=>Ue,map:()=>vt,matrix:()=>S,max:()=>kt,mean:()=>Lt,min:()=>qt,multiply:()=>Mt,norm:()=>Rt,normalize:()=>jt,ones:()=>Ke,pow:()=>zt,prod:()=>Pt,product:()=>Bt,project:()=>Ut,push:()=>$t,random:()=>$e,range:()=>Ve,rank:()=>Jt,reciprocal:()=>Ht,reduce:()=>Wt,reshape:()=>Qt,round:()=>te,row_add:()=>oe,scale:()=>ie,set:()=>se,sign:()=>ce,sin:()=>ue,sinh:()=>fe,slice:()=>de,solve:()=>Ae,sqrt:()=>Ne,square:()=>xe,subtract:()=>ve,sum:()=>ke,swap:()=>Le,tan:()=>qe,tanh:()=>Me,toArray:()=>Re,toString:()=>_e,trace:()=>ze,transpose:()=>Pe,trunc:()=>Be,zeros:()=>b});const j=r=>r.reduce((t,e)=>t.concat(Array.isArray(e)?j(e):e),[]),_=r=>ArrayBuffer.isView(r)&&!(r instanceof DataView),M=r=>r.reduce((t,e)=>t*e,1),z=r=>Array.isArray(r)||_(r)?[r.length].concat(z(r[0])):[],v=r=>[...r.slice(1).map((t,e)=>r.slice(e+1).reduce((o,i)=>o*i,1)),1],B=r=>{const{constructor:{name:t="Float32Array"}={}}=r||{};switch(t){case"Int8Array":return"int8";case"Uint8Array":return"uint8";case"Int16Array":return"int16";case"Uint16Array":return"uint16";case"Int32Array":return"int32";case"Uint32Array":return"uint32";case"Uint8ClampedArray":return"uint8c";case"Float32Array":return"float32";case"Float64Array":return"float64";default:return"float64"}},D=r=>{switch(r){case"int8":return Int8Array;case"uint8":return Uint8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"uint8c":return Uint8ClampedArray;case"float32":return Float32Array;case"float64":return Float64Array;default:return Float64Array}};const n=(...r)=>new h(...r);const x=32;class p{constructor(r){this.x=n(r);const{shape:t,strides:e,length:o}=this.x;this.length=o,this.lengthm1=o-1,this.nd=t.length,this.ndm1=this.nd-1,this.shape=Array(x).fill(0),this.strides=Array(x).fill(0),this.shapem1=Array(x).fill(0),this.coords=Array(x).fill(0),this.backstrides=Array(x).fill(0),this.factors=Array(x).fill(0),this.nd!==0&&(this.factors[this.nd-1]=1),this.contiguous=!1;let i=1,a;for(a=0;a<this.nd;a+=1)this.shape[a]=t[a],this.shapem1[a]=t[a]-1,this.strides[a]=e[a],this.backstrides[a]=e[a]*this.shapem1[a],this.coords[a]=0,t[this.ndm1-a]!==1&&(e[a]!==i&&(this.contiguous=!0),i*=t[this.ndm1-a]),a>0&&(this.factors[this.ndm1-a]=this.factors[this.nd-a]*t[this.nd-a]);this.index=0,this.pos=0}done(){return this.index>this.lengthm1}current(){const r=this.done();return{value:r?void 0:this.pos,done:r}}next1d(){const{strides:r}=this;this.pos+=r[0],this.coords[0]+=1}nextcontiguous(){this.pos+=1}next2d(){const{strides:r,shapem1:t,backstrides:e}=this;this.coords[1]<t[1]?(this.coords[1]+=1,this.pos+=r[1]):(this.coords[1]=0,this.coords[0]+=1,this.pos+=r[0]-e[1])}nextnd(){const{ndm1:r,shapem1:t,strides:e,backstrides:o}=this;let i;for(i=r;i>=0;i-=1){if(this.coords[i]<t[i]){this.coords[i]+=1,this.pos+=e[i];break}this.coords[i]=0,this.pos-=o[i]}}next(){const r=this.current();this.index+=1;const{ndm1:t,contiguous:e}=this;return t===0?this.next1d():e?this.nextcontiguous():t===1?this.next2d():this.nextnd(),r}[Symbol.iterator](){return this}}class N{constructor(...r){this.iters=r.map(c=>new p(c)),this.numiter=r.length;let t,e;for(t=0,e=0;t<this.numiter;t+=1)e=Math.max(e,this.iters[t].x.shape.length);this.nd=e,this.shape=Array(e).fill(0);let o,i,a,s;for(t=0;t<e;t+=1)for(this.shape[t]=1,i=0;i<this.numiter;i+=1)if(o=this.iters[i],a=t+o.x.shape.length-e,a>=0){if(s=o.x.shape[a],s==1)continue;if(this.shape[t]==1)this.shape[t]=s;else if(this.shape[t]!==s)throw new Error("shape mismatch")}for(s=this.shape.reduce((c,m)=>c*m,1),this.length=s,this.lengthm1=s-1,t=0;t<this.numiter;t+=1)for(o=this.iters[t],o.nd=this.nd,o.ndm1=this.nd-1,o.length=s,o.lengthm1=s-1,e=o.x.shape.length,e!==0&&(o.factors[this.nd-1]=1),i=0;i<this.nd;i+=1)o.shape[i]=this.shape[i],o.shapem1[i]=this.shape[i]-1,a=i+e-this.nd,a<0||o.x.shape[a]!==this.shape[i]?(o.contiguous=!1,o.strides[i]=0):o.strides[i]=o.x.strides[a],o.backstrides[i]=o.strides[i]*o.shapem1[i],i>0&&(o.factors[this.nd-i-1]=o.factors[this.nd-i]*this.shape[this.nd-i]);this.index=0,this.pos=Array(this.numiter).fill(0)}done(){return this.index>this.lengthm1}current(){const r=this.done();return{value:r?void 0:this.pos,done:r}}next(){const r=this.current();this.index+=1;const{numiter:t}=this;let e,o;for(o=0;o<t;o+=1)e=this.iters[o],this.pos[o]=e.pos,e.next();return r}[Symbol.iterator](){return this}}const{abs:We}=Math,O=r=>n(r).abs();function U(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=We(r[e]);return this}const{acos:Ze}=Math,K=r=>n(r).acos();function $(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=Ze(r[e]);return this}const{acosh:Qe}=Math,V=r=>n(r).acosh();function J(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=Qe(r[e]);return this}let A;try{A=require("nblas")}catch(r){}const C=A&&A.NoTrans,$o=A&&A.Trans;function X(r,t,e,o,i,a,s){if(o.length/i!==t||a.length/s!==t)throw new Error("lengths do not match");switch(r){case"float64":return A.daxpy(t,e,o,i,a,s);case"float32":return A.saxpy(t,e,o,i,a,s);default:throw new Error("wrong dtype")}}function H(r,t,e,o,i,a){if(e.length/o!==t||i.length/a!==t)throw new Error("lengths do not match");switch(r){case"float64":return A.ddot(t,e,o,i,a);case"float32":return A.sdot(t,e,o,i,a);default:throw new Error("wrong dtype")}}function Y(r,t,e,o){if(e.length/o!==t)throw new Error("lengths do not match");switch(r){case"float64":return A.idamax(t,e,o);case"float32":return A.isamax(t,e,o);default:throw new Error("wrong dtype")}}function W(r,t,e,o,i,a,s,c,m,u,y,f,l,d){const{length:I}=c,{length:G}=u,{length:q}=l;if(t===A.NoTrans&&I!==m*o||t===A.Trans&&I!==m*a)throw new Error("lengths do not match");if(e===A.NoTrans&&G!==y*a||e===A.Trans&&G!==y*i)throw new Error("lengths do not match");if(q!==d*o)throw new Error("lengths do not match");switch(r){case"float64":return A.dgemm(t,e,o,i,a,s,c,m,u,y,f,l,d);case"float32":return A.sgemm(t,e,o,i,a,s,c,m,u,y,f,l,d);default:throw new Error("wrong dtype")}}function Z(r,t,e,o){if(e.length/o!==t)throw new Error("lengths do not match");switch(r){case"float64":return A.dnrm2(t,e,o);case"float32":return A.snrm2(t,e,o);default:throw new Error("wrong dtype")}}function Q(r,t,e,o,i){if(o.length/i!==t)throw new Error("lengths do not match");switch(r){case"float64":return A.dscal(t,e,o,i);case"float32":return A.sscal(t,e,o,i);default:throw new Error("wrong dtype")}}const rr=(r,t,e=1)=>n(r).add(n(t),e);function tr(r,t=1){const{data:e,length:o,strides:i,dtype:a}=this,{data:s,strides:c}=n(r);try{const m=c[c.length-1],u=i[i.length-1];if(m!==u)throw new Error("inc_x and inc_y must be equal");X(a,o,t,s,m,e,u)}catch(m){const u=new N(this,r);for(const[y,f]of u)e[y]+=t*s[f]}return this}const{acos:ro}=Math,er=(r,t)=>n(r).angle(n(t));function or(r){return ro(this.dot(n(r))/this.norm()/n(r).norm())}const{asin:to}=Math,ar=r=>n(r).asin();function ir(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=to(r[e]);return this}const{asinh:eo}=Math,nr=r=>n(r).asinh();function sr(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=eo(r[e]);return this}const{atan:oo}=Math,mr=r=>n(r).atan();function cr(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=oo(r[e]);return this}const{atanh:ao}=Math,pr=r=>n(r).atanh();function ur(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=ao(r[e]);return this}const b=(...r)=>new h(new Float64Array(r.reduce((t,e)=>t*e,1)),{shape:r}).fill(0);const E=(r,t)=>n(r).augment(n(t));function yr(r){const[t,e]=this.shape,[o,i]=n(r).shape,{data:a}=this,{data:s}=n(r);if(o===0||i===0)return this;if(t!==o)throw new Error("rows do not match");const c=b(t,e+i),{data:m}=c;let u,y;for(u=0;u<t;u+=1)for(y=0;y<e;y+=1)m[u*(e+i)+y]=a[u*e+y];for(u=0;u<o;u+=1)for(y=0;y<i;y+=1)m[u*(e+i)+(y+e)]=s[u*i+y];return c}const fr=(r,t,e)=>n(r).binOp(n(t),e);function lr(r,t){const{data:e}=this,{data:o}=n(r),i=new N(this,r);for(const[a,s]of i)e[a]=t(e[a],o[s],a);return this}const{cbrt:io}=Math,dr=r=>n(r).cbrt();function hr(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=io(r[e]);return this}const{ceil:no}=Math,Ar=r=>n(r).ceil();function br(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=no(r[e]);return this}const Nr=(r,...t)=>{n(r).check(...t)};function Dr(...r){const{shape:t,length:e}=this;if(r.length===1){const[o]=r;if(o<0||o>e-1||!Number.isFinite(o))throw new Error("index out of bounds")}else if(!t.every((o,i)=>o>r[i]&&Number.isFinite(r[i])&&r[i]>=0))throw new Error("index out of bounds")}const xr=(r,t)=>n(r).combine(n(t));function gr(r){if(this.shape.length!==1&&r.shape.length!==1)throw new Error("combine operation not permitted for multidimensional arrays");const{length:t,data:e}=this,{length:o,data:i}=r;if(o===0)return this;if(t===0)return this.data=new(D(r.dtype))(i),this.length=o,this.dtype=r.dtype,this;const a=t+o,s=new(D(this.dtype))(a);return s.set(e),s.set(i,t),this.data=s,this.length=a,this.shape=[a],this}const vr=r=>n(r).copy();function wr(){const r=b(...this.shape),{data:t}=this,{data:e}=r,o=new N(this,r);for(const[i,a]of o)e[a]=t[i];return r}const{cos:so}=Math,kr=r=>n(r).cos();function Ir(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=so(r[e]);return this}const{cosh:mo}=Math,Lr=r=>n(r).cosh();function Gr(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=mo(r[e]);return this}const qr=(r,t)=>n(r).cross(n(t));function Tr(r){const{length:t}=this,{length:e}=r;if(t!==3||e!==3)throw new Error("vectors must have three components");const o=this.y*r.z-this.z*r.y,i=this.z*r.x-this.x*r.z,a=this.x*r.y-this.y*r.x;return this.x=o,this.y=i,this.z=a,this}const Mr=r=>n(r).det();function Er(){this.square();const[r]=this.shape,[t,e]=this.copy().lu_factor(),{data:o}=t;let i=1,a=1,s;for(s=0;s<r;s+=1)i*=o[s*r+s],s!==e[s]-1&&(a*=-1);return a*i}const Rr=r=>n(r).diagonal();function Sr(){this.square();const{length:r}=this,[t,e]=this.shape,o=Math.min(t,e);return this.reshape(r).slice(0,r,o+1)}const jr=(r,t)=>n(r).dot(n(t));function _r(r){const{data:t,length:e,strides:o,dtype:i}=this,{data:a,strides:s}=r;let c=0;try{const m=s[s.length-1],u=o[o.length-1];if(m!==u)throw new Error("inc_x and inc_y must be equal");c=H(i,e,a,m,t,u)}catch(m){const u=new N(this,r);for(const[y,f]of u)c+=t[y]*a[f]}return c}const w=r=>{const t=new h(new Float64Array(r*r),{shape:[r,r]}),{data:e}=t;let o;for(o=0;o<r;o+=1)e[o*r+o]=1;return t};let L;try{L=require("nlapack")}catch(r){}const R=(r,t,e,o,i,a,s)=>{const[c]=r.shape,{data:m}=r,u=m[o*c+i],y=1/(t+e);m[o*c+i]=u-e*(m[a*c+s]+y*u),m[a*c+s]+=e*(u-y*m[a*c+s])},zr=r=>n(r).eig();function Cr(){this.square();const[r]=this.shape;try{["float32","float64"].includes(this.dtype)||(this.dtype="float32",this.data=D(this.dtype).from(this.data));const t=L.NoEigenvector,e=L.Eigenvector,o=b(r),i=b(r),a=b(r,r),s=b(r,r),{data:c}=this,{data:m}=o,{data:u}=i,{data:y}=a,{data:f}=s;return this.dtype==="float64"&&L.dgeev(t,e,r,c,r,m,u,y,r,f,r),this.dtype==="float32"&&L.sgeev(t,e,r,c,r,m,u,y,r,f,r),[o,s]}catch(t){const{data:e}=this,o=w(r);let i=0,a=0,s=0,c=0,m=0;do{for(a=0;a<r;a+=1)for(s=a+1;s<r;s+=1)Math.abs(e[a*r+s])>=i&&(i=Math.abs(e[a*r+s]),c=a,m=s);let u;if(Math.abs(e[c*r+m])<Math.abs(e[m*r+m])*1e-36)u=e[c*r+m]/e[m*r+m];else{const d=e[m*r+m]/2*e[c*r+m];u=1/(Math.abs(d)+Math.sqrt(d*d+1))}const y=1/Math.sqrt(u*u+1),f=u*y,l=e[c*r+m];for(e[c*r+m]=0,e[c*r+c]-=u*l,e[m*r+m]+=u*l,a=0;a<c;a+=1)R(this,y,f,a,c,a,m);for(a=c+1;a<m;a+=1)R(this,y,f,c,a,a,m);for(a=m+1;a<r;a+=1)R(this,y,f,c,a,m,a);for(a=0;a<r;a+=1)R(o,y,f,a,c,a,m)}while(i>=1e-9);return[this.diagonal(),o]}}const Pr=(r,t,e=1e-6)=>n(r).equals(n(t),e);function Fr(r,t=1e-6){const{data:e}=this,{data:o}=r,i=new N(this,r);for(const[a,s]of i)if(Math.abs(e[a]-o[s])>t)return!1;return!0}const Br=(r,t)=>{n(r).equidimensional(n(t))};function Or(r){const{shape:t}=this,{shape:e}=r;if(!t.every((o,i)=>o===e[i]))throw new Error(`shapes ${t} and ${e} do not match`)}const Ur=(r,t)=>{n(r).equilateral(n(t))};function Kr(r){const{length:t}=this,{length:e}=r;if(t!==e)throw new Error(`lengths ${t} and ${e} do not match`)}const{exp:co}=Math,$r=r=>n(r).exp();function Vr(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=co(r[e]);return this}const{expm1:po}=Math,Jr=r=>n(r).expm1();function Xr(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=po(r[e]);return this}const Hr=(r,t=0)=>n(r).fill(t);function Yr(r=0){const{data:t}=this,e=new p(this);for(const o of e)t[o]=r instanceof Function?r(e.pos):r;return this}const{floor:uo}=Math,Wr=r=>n(r).floor();function Zr(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=uo(r[e]);return this}const Qr=(r,t)=>{r.forEach(t)};function rt(r){const{data:t}=this,e=new p(this);for(const o of e)r.call(this,t[o],o,t)}const{fround:yo}=Math,tt=r=>n(r).fround();function et(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=yo(r[e]);return this}let g;try{g=require("nlapack")}catch(r){}function k(r,t,e,o,i,a){if(o.length!==t*e)throw new Error("lengths do not match");switch(r){case"float64":return g.dgetrf(t,e,o,i,a);case"float32":return g.sgetrf(t,e,o,i,a);default:throw new Error("wrong dtype")}}function ot(r,t,e,o,i){if(e.length!==t*t)throw new Error("lengths do not match");switch(r){case"float64":return g.dgetri(t,e,o,i);case"float32":return g.sgetri(t,e,o,i);default:throw new Error("wrong dtype")}}function at(r,t,e,o,i,a,s,c){if(o.length!==i*t||s.length!==c*e)throw new Error("lengths do not match");switch(r){case"float64":return g.dgesv(t,e,o,i,a,s,c);case"float32":return g.sgesv(t,e,o,i,a,s,c);default:throw new Error("wrong dtype")}}const it=r=>n(r).gauss();function nt(){const{shape:[r,t],data:e,dtype:o}=this;try{const{data:i}=this,a=new Int32Array(Math.min(r,t));k(o,r,t,i,t,a);const s=new p(this);let[c,m]=s.coords;for(const u of s)m<c&&(i[u]=0),[c,m]=s.coords}catch(i){let a=0,s,c,m,u,y;for(m=0;m<r;m+=1){if(t<=a)return this;for(u=m;e[u*t+a]===0;)if(u+=1,r===u&&(u=m,a+=1,t===a))return this;if(m!==u&&this.swap(m,u),c=e[m*t+a],c!==0)for(y=0;y<t;y+=1)e[m*t+y]/=c;for(u=0;u<r;u+=1)if(s=e[u*t+a],u!==m)for(y=0;y<t;y+=1)e[u*t+y]-=e[m*t+y]*s;a+=1}for(m=0;m<r;m+=1){for(c=0,u=0;u<t;u+=1)c===0&&(c=e[m*t+u]);if(c===0)for(y=0;y<t;y+=1)e[m*t+y]/=c}}return this}const st=(r,...t)=>n(r).get(...t);function mt(...r){this.check(...r);const{data:t,shape:e}=this,{length:o}=e;let i=r[o-1],a,s;for(a=0;a<o-1;a+=1){let c=1;for(s=a+1;s<o;s+=1)c*=e[s];i+=r[a]*c}return t[i]}const ct=r=>n(r).inv();function pt(){this.square();const{shape:[r],dtype:t}=this;try{const{data:e}=this,o=new Int32Array(r);return k(t,r,r,e,r,o),ot(t,r,e,r,o),this}catch(e){const o=w(r),i=E(this,o).gauss(),a=b(r,r),s=b(r,r),{data:c}=i,{data:m}=a,{data:u}=s,y=new p(i);let[f,l]=y.coords;for(const d of y)l<r?m[f*r+l]=c[d]:u[f*r+(l-r)]=c[d],[f,l]=y.coords;if(!a.equals(o))throw new Error("matrix is not invertible");return s}}const{log:fo}=Math,ut=r=>n(r).log();function yt(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=fo(r[e]);return this}const{log10:lo}=Math,ft=r=>n(r).log10();function lt(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=lo(r[e]);return this}const{log1p:ho}=Math,dt=r=>n(r).log1p();function ht(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=ho(r[e]);return this}const{log2:Ao}=Math,At=r=>n(r).log2();function bt(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=Ao(r[e]);return this}const Nt=r=>n(r).lu();function Dt(){const[r,t]=this.copy().lu_factor(),e=r.copy(),o=r.copy(),{data:i}=e,{data:a}=o,s=new p(r);let[c,m]=s.coords;for(const u of s)m<c?a[u]=0:i[u]=c===m?1:0,[c,m]=s.coords;return[e,o,t]}const xt=r=>n(r).lu_factor();function gt(){const{data:r,shape:[t],dtype:e}=this,o=new Int32Array(t);try{k(e,t,t,r,t,o)}catch(i){let a,s,c,m,u,y,f;for(f=0;f<t;f+=1){for(m=f,a=Math.abs(r[f*t+f]),y=f+1;y<t;y+=1)s=Math.abs(r[y*t+f]),a<s&&(a=s,m=y);for(o[f]=m+1,m!==f&&this.swap(f,m),c=r[f*t+f],u=f+1;u<t;u+=1)r[u*t+f]/=c;for(u=f+1;u<t;u+=1){for(y=f+1;y<t-1;y+=2)r[u*t+y]-=r[u*t+f]*r[f*t+y],r[u*t+y+1]-=r[u*t+f]*r[f*t+y+1];y===t-1&&(r[u*t+y]-=r[u*t+f]*r[f*t+y])}}}return[this,o]}const vt=(r,t)=>n(r).map(t);function wt(r){const{data:t}=this,e=new p(this),o=r.bind(this),i=this.copy(),{data:a}=i;for(const s of e)a[s]=o(t[s],s,t);return i}const kt=r=>n(r).max();function It(){const{data:r,length:t,strides:e,dtype:o}=this;let i=Number.NEGATIVE_INFINITY;try{const a=e[e.length-1];i=r[Y(o,t,r,a)]}catch(a){const s=new p(this);for(const c of s){const m=r[c];i<m&&(i=m)}}return i}const Lt=r=>n(r).mean();function Gt(){const{data:r,length:t}=this,e=new p(this);let o=0;for(const i of e)o+=r[i];return o/t}const qt=r=>n(r).min();function Tt(){const{data:r}=this,t=new p(this);let e=Number.POSITIVE_INFINITY;for(const o of t){const i=r[o];e>i&&(e=i)}return e}const S=(r,t)=>new h(new Float64Array(r*t),{shape:[r,t]});const Mt=(r,t)=>n(r).multiply(n(t));function Et(r){const{shape:[t,e],data:o,dtype:i}=this,{shape:[a,s],data:c}=r;if(e!==a)throw new Error("sizes do not match");const m=S(t,s),{data:u}=m;try{W(i,C,C,t,s,e,1,o,e,c,s,0,u,s)}catch(y){const f=new p(m);let l,[d,I]=f.coords;for(const G of f){let q=0;for(l=0;l<e;l+=1)q+=o[d*e+l]*c[l*s+I];u[G]=q,[d,I]=f.coords}}return m}const{sqrt:bo}=Math,Rt=r=>n(r).norm();function St(){const{data:r,length:t,strides:e,dtype:o}=this;let i=0;try{const a=e[e.length-1];i=Z(o,t,r,a)}catch(a){i=bo(this.dot(this))}return i}const jt=r=>n(r).normalize();function _t(){return this.scale(1/this.norm())}const{pow:No}=Math,zt=(r,t)=>n(r).pow(t);function Ct(r){const{data:t}=this,e=new p(this);for(const o of e)t[o]=No(t[o],r);return this}const Pt=r=>n(r).prod();function Ft(){const{data:r}=this,t=new p(this);let e=1;for(const o of t)e*=r[o];return e}const Bt=(r,t)=>n(r).product(n(t));function Ot(r){const{data:t}=this,{data:e}=r,o=new N(this,r);for(const[i,a]of o)t[i]*=e[a];return this}const Ut=(r,t)=>n(r).project(n(t));function Kt(r){return r.scale(this.dot(r)/r.dot(r))}const $t=(r,t)=>n(r).push(t);function Vt(r){if(this.shape.length!==1)throw new Error("push operation not permitted for multidimensional arrays");const{data:t,length:e}=this,o=e+1,i=new(D(this.dtype))(o);return i.set(t),i[e]=r,this.data=i,this.length=o,this.shape=[o],this}const Jt=(r,t=1e-6)=>n(r).rank(t);function Xt(r=1e-6){const{data:t}=this.copy().gauss(),e=new p(this);let o=0,[i,a]=e.coords;for(const s of e)o<=i&&a>=i&&t[s]>r&&(o+=1),[i,a]=e.coords;return o}const Ht=r=>n(r).reciprocal();function Yt(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=1/r[e];return this}const Wt=(r,t,e)=>n(r).reduce(t,e);function Zt(r,t){const{data:e,length:o}=this;if(o===0&&typeof t=="undefined")throw new Error("Reduce of empty array with no initial value.");const i=new p(this),a=r.bind(this);let s;typeof t=="undefined"?(s=e[0],i.next()):s=t;for(const c of i)s=a(s,e[c],c,e);return s}const Qt=(r,...t)=>n(r).reshape(...t);function re(...r){const{length:t}=this;if(r.reduce((e,o)=>e*o,1)!==t)throw new Error(`shape ${r} does not match length ${t}`);return this.shape=r,this.strides=v(r),this}const{round:Do}=Math,te=r=>n(r).round();function ee(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=Do(r[e]);return this}const oe=(r,t,e,o=1)=>n(r).row_add(t,e,o);function ae(r,t,e=1){this.check(r,0),this.check(t,0);const[,o]=this.shape,{data:i}=this;let a;for(a=0;a<o;a+=1)i[r*o+a]+=i[t*o+a]*e;return this}const ie=(r,t)=>n(r).scale(t);function ne(r){const{data:t,length:e,strides:o,dtype:i}=this;try{const a=o[o.length-1];Q(i,e,r,t,a)}catch(a){const s=new p(this);for(const c of s)t[c]*=r}return this}const se=(r,...t)=>{r.set(...t)};function me(...r){const t=r.slice(0,-1),e=r[r.length-1];this.check(...t);const{shape:o}=this;let i=t[t.length-1],a;for(a=0;a<t.length-1;a+=1)i+=t[a]*o[a+1];this.data[i]=e}const{sign:xo}=Math,ce=r=>n(r).sign();function pe(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=xo(r[e]);return this}const{sin:go}=Math,ue=r=>n(r).sin();function ye(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=go(r[e]);return this}const{sinh:vo}=Math,fe=r=>n(r).sinh();function le(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=vo(r[e]);return this}const de=(r,t,e,o)=>n(r).slice(t,e,o);function he(r=0,t=this.shape[0],e=1){const{data:o,shape:i}=this,a=i.length;if(r<0||t<0)return this.slice(r<0?i[i.length-1]+r:r,t<0?i[i.length-1]+t:t);if(r>t)return this.slice(t,r,e);if(e<=0)throw new Error("step argument has to be a positive integer");const s=[Math.ceil((t-r)/Math.abs(e)),...i.slice(1)],c=M(s),m=v(s),u=a>1?o.subarray(r*s[s.length-1],t*s[s.length-1]):o.subarray(r,t);return m[0]*=e,new h(u,{shape:s,length:c,strides:m})}const Ae=(r,t)=>n(r).solve(n(t));function be(r){const{data:t,dtype:e}=this,{data:o,shape:[i,a]}=r;try{const s=new Int32Array(i);at(e,i,a,t,i,s,o,a)}catch(s){const[c,m]=this.lu_factor(),{data:u}=c,{data:y}=r;let f,l,d;for(f=0;f<m.length;f+=1)f!==m[f]-1&&r.swap(f,m[f]-1);for(d=0;d<a;d+=1){for(f=0;f<i;f+=1)for(l=0;l<f;l+=1)y[f*a+d]-=u[f*i+l]*y[l*a+d];for(f=i-1;f>=0;f-=1){for(l=f+1;l<i;l+=1)y[f*a+d]-=u[f*i+l]*y[l*a+d];y[f*a+d]/=u[f*i+f]}}}return r}const{sqrt:wo}=Math,Ne=r=>n(r).sqrt();function De(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=wo(r[e]);return this}const xe=r=>{n(r).square()};function ge(){const{length:r}=this.shape,[t,e]=this.shape;if(r!==2||t!==e)throw new Error("matrix is not square")}const ve=(r,t)=>n(r).subtract(n(t));function we(r){return this.add(r,-1)}const ke=r=>n(r).sum();function Ie(){const{data:r}=this,t=new p(this);let e=0;for(const o of t)e+=r[o];return e}const Le=(r,t,e)=>n(r).swap(t,e);function Ge(r,t){this.check(r,0),this.check(t,0);const{data:e}=this,[,o]=this.shape,i=e.slice(r*o,(r+1)*o);return e.copyWithin(r*o,t*o,(t+1)*o),e.set(i,t*o),this}const{tan:ko}=Math,qe=r=>n(r).tan();function Te(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=ko(r[e]);return this}const{tanh:Io}=Math,Me=r=>n(r).tanh();function Ee(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=Io(r[e]);return this}const Re=r=>n(r).toArray();function Se(r=0,t=0){const{data:e,shape:o,strides:i}=this,{length:a}=o;if(t>=a)return e[r];const s=o[t],c=i[t],m=[];for(let u=0;u<s;u++){const y=this.toArray(r,t+1);if(y===null)return null;m[u]=y,r+=c}return m}const je=Ye(require("util"));const _e=r=>n(r).toString();function P(){return`array(${je.inspect(this.toArray(),{depth:10,breakLength:40})}, dtype=${this.dtype})`}const ze=r=>n(r).trace();function Ce(){const[r,t]=this.shape,{data:e}=this,o=Math.min(r,t);let i=0,a;for(a=0;a<o;a+=1)i+=e[a*t+a];return i}const Pe=r=>n(r).transpose();function Fe(){if(this.shape.length<2)return this;let r=this.shape[0];return this.shape[0]=this.shape[1],this.shape[1]=r,r=this.strides[0],this.strides[0]=this.strides[1],this.strides[1]=r,this}const{trunc:Lo}=Math,Be=r=>n(r).trunc();function Oe(){const{data:r}=this,t=new p(this);for(const e of t)r[e]=Lo(r[e]);return this}const Ue=r=>{if(r<0)throw new Error("invalid n");const t=new Float64Array(r*r),e=new h(t,{shape:[r,r]}),o=new p(e);let[i,a]=o.coords;for(const s of o){const c=r-i-1,m=r-a-1;t[s]=(a+c*2+1)%r*r+(m+c*2+1)%r+1,[i,a]=o.coords}return e};const Ke=(...r)=>new h(new Float64Array(r.reduce((t,e)=>t*e,1)),{shape:r}).fill(1);const $e=(...r)=>new h(new Float64Array(r.reduce((t,e)=>t*e,1)),{shape:r}).map(()=>Math.random());const Ve=(...r)=>{const t=Float64Array;let e=!1,o,i,a;switch(r.length){case 2:a=r.pop(),i=1,o=r.pop();break;case 3:a=r.pop(),i=r.pop(),o=r.pop();break;default:throw new Error("invalid range")}if(a-o<0){const u=a;a=o,o=u,e=!0}if(i>a-o)throw new Error("invalid range");const s=new t(Math.ceil((a-o)/i));let c=o,m=0;if(e)for(;c<a;c+=i,m+=1)s[m]=a-c+o;else for(;c<a;c+=i,m+=1)s[m]=c;return new h(s)};const Go=Symbol.for("nodejs.util.inspect.custom");var Au;class h{constructor(r,t){this.data=new Float64Array(0);this.dtype="float64";this.length=0;this.shape=[0];this.strides=[0];this[Au]=P;this.abs=U;this.acos=$;this.acosh=J;this.add=tr;this.angle=or;this.asin=ir;this.asinh=sr;this.atan=cr;this.atanh=ur;this.augment=yr;this.binOp=lr;this.cbrt=hr;this.ceil=br;this.check=Dr;this.combine=gr;this.copy=wr;this.cos=Ir;this.cosh=Gr;this.cross=Tr;this.det=Er;this.diagonal=Sr;this.dot=_r;this.eig=Cr;this.equals=Fr;this.equidimensional=Or;this.equilateral=Kr;this.exp=Vr;this.expm1=Xr;this.fill=Yr;this.floor=Zr;this.forEach=rt;this.fround=et;this.gauss=nt;this.get=mt;this.inv=pt;this.log=yt;this.log10=lt;this.log1p=ht;this.log2=bt;this.lu=Dt;this.lu_factor=gt;this.map=wt;this.max=It;this.mean=Gt;this.min=Tt;this.multiply=Et;this.norm=St;this.normalize=_t;this.pow=Ct;this.prod=Ft;this.product=Ot;this.project=Kt;this.push=Vt;this.rank=Xt;this.reciprocal=Yt;this.reduce=Zt;this.reshape=re;this.round=ee;this.row_add=ae;this.scale=ne;this.set=me;this.sign=pe;this.sin=ye;this.sinh=le;this.slice=he;this.solve=be;this.sqrt=De;this.square=ge;this.subtract=we;this.sum=Ie;this.swap=Ge;this.tan=Te;this.tanh=Ee;this.toArray=Se;this.toString=P;this.trace=Ce;this.transpose=Fe;this.trunc=Oe;if(!r)return;if(r instanceof h)return r;if(r instanceof p){if(!t||!t.dtype)throw new Error("dtype is missing");r.shape&&(t.shape=r.shape);const s=r.length;r=new(D(t.dtype))(s)}const{shape:e=z(r),length:o=M(e),strides:i=v(e),dtype:a=B(r)}=t||{};this.data=_(r)?r:new(D(a))(j(r)),this.shape=e,this.length=o,this.dtype=a,this.strides=i}get x(){return this.get(0)}set x(r){this.set(0,r)}get y(){return this.get(1)}set y(r){this.set(1,r)}get z(){return this.get(2)}set z(r){this.set(2,r)}get w(){return this.get(3)}set w(r){this.set(3,r)}get T(){return this.copy().transpose()}}Au=Go;try{window.v=h}catch(r){}
//# sourceMappingURL=index.js.map
